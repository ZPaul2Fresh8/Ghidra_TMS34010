
define token size_word(16)
	word 		= (0,15)
;

define token tok32(32)
	imm32 		= (0,31)
	imm32s 		= (0,31) signed
	addr2 		= (0,31)
	addr_byte1	= (16,31)
	addr_byte2	= (0,23)
;

define token tok16(16)
	bits_11_15	= (11,15)		#dsjs
	bits_10_15	= (10,15)
	bits_10		= (10,10)		#dsjs
	bits_12_15 	= (12,15)
	bits_9_15	= (9,15)
	bits_9		= (9,9) dec
	bits_8_15	= (8,15)		#line z
	bits_8_11 	= (8,11)
	bits_7		= (7,7)			#line z
	bits_6_8	= (6,8)			#setf
	bits_5_15	= (5, 15)
	bits_5_9	= (5,9)
	bits_5_8_A	= (5,8)
	bits_5_8_B	= (5,8)
	bits_5_8	= (5,8)
	bits_5		= (5,5) dec		#setf
	bits_4		= (4,4)
	bits_0_8	= (0,8)
	bits_0_7s	= (0,7) signed
	bits_0_6	= (0,6)			#line z
	bits_0_3_A	= (0,3)
	bits_0_3_B	= (0,3)
	bits_0_15	= (0,15)
	bits_0_15s	= (0,15) signed
	bits_0_4	= (0,4)			# setf

	bits_8_11_B = (8,11)
	
	#offsets
	offset1 = (0,15)
	offset2 = (0,15)
;


# =====================================================================================================================================#
#
# 								TABLES
#
# =====================================================================================================================================#
attach variables [ bits_0_3_A ] [ A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14 SP ];
attach variables [ bits_0_3_B ] [ B0 B1 B2 B3 B4 B5 B6 B7 B8 B9 B10 B11 B12 B13 B14 SP ];
attach variables [ bits_5_8_A ] [ A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14 SP ];
attach variables [ bits_5_8_B ] [ B0 B1 B2 B3 B4 B5 B6 B7 B8 B9 B10 B11 B12 B13 B14 SP ];

# Rs
Rd: bits_0_3_A is bits_4=0 & bits_0_3_A { export bits_0_3_A; }
Rd: bits_0_3_B is bits_4=1 & bits_0_3_B { export bits_0_3_B; }
#Rd
Rs: bits_5_8_A is bits_4=0 & bits_5_8_A { export bits_5_8_A; }
Rs: bits_5_8_B is bits_4=1 & bits_5_8_B { export bits_5_8_B; }

Constant: bits_5_9 is bits_5_9 { export bits_5_9; }

# DSJS
addr5: fwd is bits_5_9 & bits_10 = 0 [fwd = inst_next + (bits_5_9 * 2);] {export *:4 fwd;}
addr5: bwd is bits_5_9 & bits_10 = 1 [bwd = inst_next - (bits_5_9 * 2);] {export *:4 bwd;}
addr8: addy is bits_0_7s [addy = inst_next + (bits_0_7s * 2);] {export *:4 addy;} 
addr16: addy is bits_0_15s [addy = inst_next + (bits_0_15s * 2);] {export *:4 addy;}
addr32: addy is imm32 [addy = (imm32 / 8) & 0xfffff;] {export *:4 addy;}

cc: "" is bits_8_11=0  	{ local tmp:1 = 1; export tmp; }
cc: "P"  is bits_8_11=1  { local tmp:1 = (!$(N_Flag) & !$(Z_Flag)) != 0; export tmp; }
cc: "LS" is bits_8_11=2  { local tmp:1 = ($(C_Flag) | $(N_Flag)) != 0; export tmp; }
cc: "HI" is bits_8_11=3  { local tmp:1 = (!$(C_Flag) & !$(N_Flag)) != 0; export tmp; }
cc: "LT" is bits_8_11=4  { local tmp:1 = ($(N_Flag) & !$(V_Flag)) | (!$(N_Flag) & $(V_Flag)) != 0; export tmp; }
cc: "GE" is bits_8_11=5  { local tmp:1 = ($(N_Flag) & $(V_Flag)) | (!$(N_Flag) & !$(V_Flag)) != 0; export tmp; }
cc: "LE" is bits_8_11=6  { local tmp:1 = ($(N_Flag) & !$(V_Flag)) | (!$(N_Flag) & $(V_Flag)) | $(Z_Flag) != 0; export tmp; }
cc: "GT" is bits_8_11=7  { local tmp:1 = ($(N_Flag) & $(V_Flag) & !$(Z_Flag)) | (!$(N_Flag) & !$(V_Flag) & !$(Z_Flag)) != 0; export tmp; }
cc: "C"	 is bits_8_11=8  { local tmp:1 = $(C_Flag) != 0; export tmp; }
cc: "NC" is bits_8_11=9  { local tmp:1 = !$(C_Flag) != 0; export tmp; }
cc: "EQ" is bits_8_11=10 { local tmp:1 = $(Z_Flag) != 0; export tmp; }
cc: "NE" is bits_8_11=11 { local tmp:1 = !$(Z_Flag) != 0; export tmp; }
cc: "V"  is bits_8_11=12 { local tmp:1 = $(V_Flag) != 0; export tmp; }
cc: "NV" is bits_8_11=13 { local tmp:1 = !$(V_Flag) != 0; export tmp; }
cc: "N"  is bits_8_11=14 { local tmp:1 = $(N_Flag) != 0; export tmp; }
cc: "NN" is bits_8_11=15 { local tmp:1 = !$(N_Flag) != 0; export tmp; }



# =====================================================================================================================================#
#
# 								MACROS
#
# =====================================================================================================================================#
macro Update_N_Flag(N)
{
	$(N_Flag) = N < 0;
}

macro Update_C_Flag(C)
{
	
}

macro Update_Z_Flag(Z)
{
	$(Z_Flag) = Z == 0;
}


macro Update_V_Flag(V)
{
	
}


# =====================================================================================================================================#
#
# 								SUBTABLES
#
# =====================================================================================================================================#

# -------------------------------------------------------------------------------------------------------------------------------------#
# ABS Rd						Store Absolute Value																0000 0011 100R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:ABS Rd is bits_5_15=0b00000011100 & Rd
{
	if(Rd > 0x80000000) goto <OVERFLOW>; #
	if(Rd == 0) goto <ZERO>;
	if(Rd < 0) goto <MAKE_POS>;
	
	#<POS>
	$(N_Flag) = 1;
	$(Z_Flag) = 0;
	
	
	<ZERO>
	$(N_Flag) = 0;
	$(Z_Flag) = 1;
	
	
	<OVERFLOW>
	$(V_Flag) = 1;
	
	<MAKE_POS>
	Rd = 0 - Rd;
	
	$(N_Flag) = 0; # set flag since original value was neg
}

# -------------------------------------------------------------------------------------------------------------------------------------#
# ADD Rs,Rd						Add Registers																		0100 000S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:ADD Rs,Rd is bits_9_15=0b0100000 & Rs & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# ADD Rs,Rd						Add Registers with Carry															0100 001S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:ADDC Rs,Rd is bits_9_15=0b0100001 & Rs & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# ADDI IW						Add Immediate (16-bytes)															0000 1011 000R DDDD					
# -------------------------------------------------------------------------------------------------------------------------------------#
:ADDI word,Rd is bits_5_15=0b00001011000 & Rd; word
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# ADDI IL						Add Immediate (32-bytes)															0000 1011 001R DDDD					
# -------------------------------------------------------------------------------------------------------------------------------------#
:ADDI link,Rd is bits_5_15=0b00001011001 & Rd; imm32 [link=(imm32 / 8) & 0xfffff;]
{
	Rd = link;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# ADDK K,Rd						Add Constant (5-bits)																0001 00KK KKKR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:ADDK Constant,Rd is bits_10_15=0b000100 & Constant & Rd
{
	Rd = Rd + Constant;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# ADDXY Rs,Rd					Add Registers in XY Mode															1110 000S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:ADDXY Rs,Rd is bits_9_15=0b1110000 & Rs & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# AND Rs,Rd						AND Registers																		0101 000S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:AND Rs,Rd is bits_9_15=0b0101000 & Rs & Rd
{
	Rd = Rs & Rd;
	
	if(Rd==0) goto <SET_Z_FLAG>;
	
	$(Z_Flag) = 0;
	goto inst_next;
	
	<SET_Z_FLAG>
	$(Z_Flag) = 1;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# ANDN Rs,Rd					AND Registers with Compliment														0101 001S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:ANDN Rs,Rd is bits_9_15=0b0101001 & Rs & Rd
{
	Rd = ~Rs & Rd; 
	
	# set flags
	if(Rd==0) goto <SET_Z_FLAG>;
	
	$(Z_Flag) = 0;
	goto inst_next;
	
	<SET_Z_FLAG>
	$(Z_Flag) = 1;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# ANDI IL,Rd					AND Immediate (32-bits)																0000 1011 100R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:ANDI IL,Rd is bits_5_15=0b00001011100 & Rd; imm32s
[IL=~imm32s;]
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# ANDNI IL,Rd					AND NOT Immediate (32-bits)															0000 1011 101R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
# pattern might be wrong as ANDNI is the same as ANDI, error in manual?
#:ANDNI imm32,Rd is bits_5_15=0b00001011101 & Rd; imm32
#{
	
#}


# -------------------------------------------------------------------------------------------------------------------------------------#
#BTST 4h,a0						Test Register Bit, Constant															0001 11KK KKKR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:BTST K,Rd is bits_10_15=0b000111 & bits_5_9 & Rd [ K=~bits_5_9 & 0x1f; ]
 {
 	goto inst_next;
 }
	 
	 
# -------------------------------------------------------------------------------------------------------------------------------------#
#BTST Rs,Rd						Test Register Bit, Register															0100 101S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:BTST Rs,Rd is bits_9_15=0b0100101 & Rs & Rd
 {
 	goto inst_next;
 }


# -------------------------------------------------------------------------------------------------------------------------------------#
# CALL Rd						Call Register																		0000 1001 001R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:CALL Rd is bits_5_15=0b00001001001 & Rd
{
	call Rd;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# CALLA	FF805000				Call Absolute Address																0000 1101 0101 1111
# -------------------------------------------------------------------------------------------------------------------------------------#
:CALLA addr32 is word=0x0D5F; addr32
{
	call addr32;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# CALLR FF805000	Call Relative Address									0000  1101 0011 1111
# -------------------------------------------------------------------------------------------------------------------------------------#
:CALLR addr16 is bits_0_15=0x0D3F; addr16
{ 
	
	call addr16;

}


# -------------------------------------------------------------------------------------------------------------------------------------#
# CLR Rd					Clear Register									0101 011D DDDR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:CLR Rd is bits_9_15=0b0101011 & bits_5_8_A & Rd
{
	#XOR itself to clear+
	# Rd = Rd ^ Rd;
	Rd = 0;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# CLRC							Clear Carry																			0000 0011 0010 0000
# -------------------------------------------------------------------------------------------------------------------------------------#
:CLRC is word=0x320 [ C=1; globalset(inst_next,C); ]
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# CMP Rs,Rd						Compare Registers																	0100 100S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:CMP Rs, Rd is bits_9_15=0b0100100 & Rs & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# CMPI							Compare Immediate (16-bits)															0000 1011 010R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:CMPI IW,Rd is bits_5_15=0b00001011010 & Rd; bits_0_15s
[IW = ~bits_0_15s;]
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# CMPI							Compare Immediate (32-bits)															0000 1011 011R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:CMPI IL,Rd is bits_5_15=0b00001011011 & Rd; imm32s
[IL = ~imm32s;]
{

	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# CMPXY Rs,Rd					Compare X and Y halves of Registers													1110 010S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:CMPXY Rs,Rd is bits_9_15=0b1110010 & Rs & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# CPW Rs,Rd						Compare Point to Window																1110 011S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:CMPW Rs,Rd is bits_9_15=0b1110011 & Rs & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# CVXYL Rd,Rs					Convert XY Address to Linear Address												1110 100S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:CVXYL Rd,Rs is bits_9_15=0b1110100 & Rs & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# DEC Rd						Decrement Register																	0001 0100 001R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:DEC Rd is bits_5_15=0b00010100001 & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# Disable Interrupts
# -------------------------------------------------------------------------------------------------------------------------------------#
:DINT is word = 0x0360
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# DIVS Rs,Rd					Divide Registers Signed																0101 100S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:DIVS Rs,Rd is bits_9_15=0b0101100 & Rs & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# DIVU Rs,Rd					Divide Registers Unsigned															0101 101S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:DIVU Rs,Rd is bits_9_15=0b0101101 & Rs & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# DRAV Rs,Rd					Draw and Advance																	1111 011S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:DRAV Rs,Rd is bits_9_15=0b1111011 & Rs & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# DSJ Rd,Address				Decrement Register and skip															0000 1101 100R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:DSJ Rd,addr16 is bits_5_15=0b00001101100 & Rd; addr16
{
		Rd = Rd -1;
		if ( Rd != 0) goto addr16;		
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# DSJEQ Rd,Address				Conditionally Decrement Register and skip											0000 1101 101R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:DSJEQ Rd,addr16 is bits_5_15=0b00001101101 & Rd; addr16
{
		if($(Z_Flag)==0) goto inst_next;
		
		Rd = Rd -1;
		
		if ( Rd != 0) goto addr16;		
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# DSJEQ Rd,Address				Conditionally Decrement Register and skip											0000 1101 110R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:DSJNE Rd,addr16 is bits_5_15=0b00001101110 & Rd; addr16
{
		if($(Z_Flag)==1) goto inst_next;
		
		Rd = Rd -1;
		
		if ( Rd != 0) goto addr16;		
}

# -------------------------------------------------------------------------------------------------------------------------------------#
# DSJS Rd,Address				Decrement Register and skip jump short.												0011 1DKK KKKR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:DSJS Rd,addr5 is bits_11_15=0b00111 & addr5 & Rd
{
		Rd = Rd -1;
		if ( Rd != 0) goto addr5;		
}

# -------------------------------------------------------------------------------------------------------------------------------------#
# Enable Interrupts
# -------------------------------------------------------------------------------------------------------------------------------------#
:EINT is word = 0x0D60
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# EMU							Initiate Emulation																	0000 0001 0000 0000
# -------------------------------------------------------------------------------------------------------------------------------------#
:EMU is bits_0_15=0x100
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# EXGF Rd,F						Exchange Field Size																	1101 01F1 000R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:EXGF Rd,bits_9 is bits_10_15=0b110101 & bits_9 & bits_5_8=0b1000 & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# EXGPC Rd						Exchange Program Counter with Register												0000 0001 001R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:EXGPC Rd is bits_5_15=0b00000001001 & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# FILL L						Fill Array with processed pixels, Linear											0000 1111 1100 0000
# -------------------------------------------------------------------------------------------------------------------------------------#
:FILL_L is bits_0_15=0xfc0
{
	#
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# FILL XY						Fill Array with processed pixels, XY												0000 1111 1110 0000
# -------------------------------------------------------------------------------------------------------------------------------------#
:FILL_XY is bits_0_15=0xfe0
{
	#
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# GETPC	Rd						Get Program Counter into Register													0000 0001 010R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:GETPC Rd is bits_5_15=0b00000001010 & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# GETST Rd						Get Status Register into Register													0000 0001 100R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:GETST Rd is bits_5_15=0b00000001100 & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# INC Rd						Increment Register																	0001 0000 001R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:INC Rd is bits_5_15=0b00010000001 & Rd
{
	goto inst_next;
}

# -------------------------------------------------------------------------------------------------------------------------------------#
# JAcc Address					Absolute Address Conditional														1100 cond 1000 0000
# -------------------------------------------------------------------------------------------------------------------------------------#
:JA^cc addr32 is cc & bits_12_15=0b1100 &  bits_0_7s=0b10000000; addr32
{
	if (cc) goto addr32;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
#JRcc Address					Jump Relative Conditonal Long														1100 cond 0000 0000
# -------------------------------------------------------------------------------------------------------------------------------------#
:JR^cc addr16 is cc & bits_12_15=0b1100 & bits_0_7s=0; addr16
{
	if(cc) goto addr16;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
#JRcc Address					Jump Relative Conditional Short														1100 cond xxxx xxxx
# -------------------------------------------------------------------------------------------------------------------------------------#
#attach names [ bits_8_11_B ] [ UC P LS HI LT GE LE GT C NC EQ NE V NV N NN ];
:JR^cc addr8 is cc & bits_12_15=0b1100 & addr8
{
	if(cc) goto addr8;
}



# -------------------------------------------------------------------------------------------------------------------------------------#
# JUMP Rd						Jump Indirect																		0000 0001 011R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
# Will throw errors since register won't natively have a valid address.
:JUMP Rd is bits_5_15=0b00000001011 & Rd
{
	goto Rd;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# LINE Z						Line Draw																			1101 1111 Z001 1010
# -------------------------------------------------------------------------------------------------------------------------------------#
:LINE bits_7 is bits_8_15=0b11011111 & bits_7 & bits_0_6=0b0011010
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# LMO Rs,Rd						Leftmost One																		0110 101S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:LMO Rs,Rd is bits_9_15=0b0110101 & Rs & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MMTM Rs,List					Move Multiple Registers To Memory													0000 1001 100R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
#SP A14 A13 A12 A11 A10 A9 A8 A7 A6 A5 A4 A3 A2 A1 AO
:MMTM Rd,bits_0_15 is bits_5_15=0b00001001100 & Rd; bits_0_15
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MMFM Rs,List					Move Multiple Registers From Memory													0000 1001 101R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MMFM Rd,bits_0_15 is bits_5_15=0b00001001101 & Rd; bits_0_15
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MODS Rs,Rd					Modulus Signed																		0110 110S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MODS Rs,Rd is bits_9_15=0b0110110 & Rs & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MODU Rs,Rd					Modulus Unsigned																	0110 111S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MODU Rs,Rd is bits_9_15=0b0110111 & Rs & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MPYS Rs,Rd					Multiply Registers (Signed)															0101 110S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MPYS Rs,Rd is bits_9_15=0b0101110 & Rs & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MPYU Rs,Rd					Multiply Registers (Unsigned)														0101 111S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MPYU Rs,Rd is bits_9_15=0b0101111 & Rs & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVB Rs,*Rd					Move Byte - Register to Indirect													1000 110S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVB Rs,*Rd is bits_9_15=0b1000110 & Rs & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVB *Rs,Rd					Move Byte - Indirect to Register													1000 111S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVB *Rs,Rd is bits_9_15=0b1000111 & Rs & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVB *Rs,*Rd					Move Byte - Indirect to Indirect													1001 110S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVB *Rs,*Rd is bits_9_15=0b1001110 & Rs & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVB *Rs,*Rd(Disp)			Move Byte - Indirect to Indirect with Displacement									1010 110S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVB *Rs,*Rd(offset2) is bits_9_15=0b1010110 & Rs & Rd; offset2
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVB *Rs(Disp,*Rd			Move Byte - Indirect with Displacement to Indirect										1010 111S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVB *Rs(offset1),*Rd is bits_9_15=0b1010111 & Rs & Rd; offset1
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVB *Rs(Disp),*Rd(Disp)			Move Byte - Indirect with Displacement to Indirect with Displacement			1011 110S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVB *Rs(offset1),*Rd(offset2) is bits_9_15=0b1011110 & Rs & Rd; offset1; offset2
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVB Rs,@DAddress					Move Byte - Register to Absolute												0000 0101 111R SSSS
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVB Rd,imm32 is bits_5_15=0b00000101111 & Rd; imm32
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVB @SAddress,Rd					Move Byte - Absolute to Register												0000 0111 111R SSSS
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVB imm32,Rd is bits_5_15=0b00000111111 & Rd; imm32
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVB @SAddress,@DAddress			Move Byte - Absolute to Absolute												0000 0011 0100 0000
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVB imm32,@addr2 is word=0x340; imm32;addr2
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE Rs,Rd					Move Register to Register															0100 11MS SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVE Rs,Rd is bits_10_15=0b010011 & bits_9 & Rd & bits_4 & Rs
{
	Rs = Rd;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE Rs,*Rd,F					Move Field - Register to Indirect													1000 00FS SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVE Rs, *Rd, bits_9 is bits_10_15=0b100000 & bits_9 & Rd & bits_4 & Rs
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE Rs,-*Rd,F				Move Field - Register to Indirect(Predecrement)										1010 00FS SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVE Rs, -*Rd, bits_9 is bits_10_15=0b101000 & bits_9 & Rd & bits_4 & Rs
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE Rs,*Rd+,F				Move Field - Register to Indirect(Post Inc)											1001 00FS SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVE Rs, *Rd+, bits_9 is bits_10_15=0b100100 & bits_9 & Rd & bits_4 & Rs
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE *Rs,Rd,F					Move Field - Indirect to Register													1000 01FS SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVE *Rs, Rd, bits_9 is bits_10_15=0b100001 & bits_9 & Rd & bits_4 & Rs
{
	Rs = *[register]Rd;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE -*Rs,Rd,F				Move Field - Indirect (Pre Inc) to Register											1010 01FS SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVE -*Rs, Rd, bits_9 is bits_10_15=0b101001 & bits_9 & Rd & bits_4 & Rs
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE *Rs+,Rd,F				Move Field - Indirect (Post Inc) to Register										1001 01FS SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVE *Rs+, Rd, bits_9 is bits_10_15=0b100101 & bits_9 & Rd & bits_4 & Rs
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE *Rs,*Rd,F				Move Field - Indirect to Indirect													1000 10FS SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVE *Rs, *Rd, bits_9 is bits_10_15=0b100010 & bits_9 & Rd & bits_4 & Rs
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE -*Rs,-*Rd,F				Move Field - Indirect(Predecrement) to Indirect(Predecrement)						1010 10FS SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVE -*Rs, -*Rd, bits_9 is bits_10_15=0b101010 & bits_9 & Rd & bits_4 & Rs
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE *Rs+,*Rd+,F				Move Field - Indirect(Postincrement) to Indirect(Postincrement)						1010 10FS SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVE *Rs+, *Rd+, bits_9 is bits_10_15=0b100110 & bits_9 & Rd & bits_4 & Rs
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE Rs,*Rd(Disp),F			Move Field - Register to Indirect(Displacement)										1011 00FS SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVE Rs, *Rd(offset2), bits_9 is bits_10_15=0b101100 & bits_9 & Rd & bits_4 & Rs;
offset2
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE *Rs(Disp),Rd,F			Move Field - Indirect(Displacement) to Register										1011 01FS SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVE *Rs(offset1), Rd, bits_9 is bits_10_15=0b101101 & bits_9 & Rd & bits_4 & Rs;
offset1
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE *Rs(Disp),*Rd+,F			Move Field - Indirect(Displacement) to Indirect (Post Increment)					1101 00FS SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVE *Rs(offset1), *Rd+, bits_9 is bits_10_15=0b110100 & bits_9 & Rs & Rd;
offset1
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE *Rs(Disp),*Rd(Disp),F	Move Field - Indirect(Displacement) to Indirect (Displacement)						1011 10FS SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVE *Rs(offset1), *Rd(offset2), bits_9 is bits_10_15=0b101110 & bits_9 & Rs & Rd;
offset1; offset2
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE Rs,@DAddress,F			Move Field - Register to Absolute													0000 01F1 100R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVE Rd,@^imm32,bits_9 is bits_10_15=0b000001 & bits_9 & bits_5_8=0b1100 & Rd;
imm32
{
	*[ram]:4 Rd = imm32:4;
	#goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE @SAddress,Rd,F			Move Field - Absolute to Register													0000 01F1 101R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVE @^imm32,Rd,bits_9 is bits_10_15=0b000001 & bits_9 & bits_5_8=0b1101 & Rd;
imm32
{
	#if(bits_9 == 1) goto <LWORD>;
	#Rd = *[ram] imm32;
	#goto inst_next;
	
	#<LWORD>
	Rd = *[ram]:4 imm32:4;

}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE @SAddress,*Rd+,F			Move Field - Absolute to Indirect (Postincrement)									1101 01F0 000R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVE imm32,*Rd+,bits_9 is bits_10_15=0b110101 & bits_9 & bits_5_8=0b0000 & Rd;
imm32
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE @SAddress,@DAddress,F	Move Field - Absolute to Absolute													0000 01F1 1100 DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
# TODO: Error: Equal constraint is impossible to match: for table "instruction" constructor from tms34010.slaspec:881
:MOVE imm32,@addr2,bits_9 is bits_10_15=0b000001 & bits_9 & bits_0_8=0b111000000;
imm32; addr2
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVI IW,Rd					Move Immediate (16-bits)															0000 1001 110R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVI bits_0_15,Rd is bits_5_15=0b00001001110 & Rd; bits_0_15
{ 
	Rd = bits_0_15;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVI IL,Rd					Move Immediate (32-bits)															0000 1001 111R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
#:MOVI link,Rd is bits_5_15=0b00001001111 & Rd; imm32 [link=(imm32 / 8) & 0xfffff;]
#:MOVI link,Rd is bits_5_15=0b00001001111 & Rd; addr_byte1 & addr_byte2 [link=(addr_byte1 << 0x10 | addr_byte2);]
:MOVI imm32,Rd is bits_5_15=0b00001001111 & Rd; imm32 
#! fix me !
{
	Rd = imm32;
}


#addr_byte1	= (24,31)
#addr_byte2 = (0,23)



# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVK 1h,A1					Move Constant																		0001 10KK KKKR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVK Constant,Rd is bits_10_15=0b000110 & Constant & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVX Rs,Rd					Move X half of register																1110 110S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVX Rs,Rd is bits_9_15=0b1110110 & Rs & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVY Rs,Rd					Move Y half of register																1110 111S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVY Rs,Rd is bits_9_15=0b1110111 & Rs & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# NEG Rd						Negate Register																		0000 0011 101R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:NEG Rd is bits_5_15=0b00000011101 & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# NEG Rd						Negate Register	with Borrow															0000 0011 110R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:NEGB Rd is bits_5_15=0b00000011110 & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# No Operation
# -------------------------------------------------------------------------------------------------------------------------------------#
:NOP is word = 0x300
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# NOT Rd						Not Register																		0000 0011 111R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:NOT Rd is bits_5_15=0b00000011111 & Rd
{
	#done
	Rd = ~Rd;
	Update_Z_Flag(Rd);
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# OR Rs,Rd					OR Registers																		0101 010S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:OR Rs,Rd is bits_9_15=0b0101010 & Rs & Rd
{
	#done
	Rd = Rs | Rd;
	Update_Z_Flag(Rd);
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# ORI L,Rd						OR Immediate (32-bits)																0000 1011 101R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:ORI imm32,Rd is bits_5_15=0b00001011101 & Rd; imm32
{
	#done
	Rd = Rd | imm32;
	Update_Z_Flag(Rd);
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# PIXBLT B,L					Pixel Block transfer, binary to linear												0000 1111 1000 0000
# -------------------------------------------------------------------------------------------------------------------------------------#
:PIXBLT_B_L is bits_0_15=0xf80
{
	#
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# PIXBLT B,XY					Pixel Block transfer, and expand, binary to XY										0000 1111 1010 0000
# -------------------------------------------------------------------------------------------------------------------------------------#
:PIXBLT_B_XY is bits_0_15=0xfa0
{
	#
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# PIXBLT L,L					Pixel Block transfer, linear to linear												0000 1111 0000 0000
# -------------------------------------------------------------------------------------------------------------------------------------#
:PIXBLT_L_L is bits_0_15=0xf00
{
	#
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# PIXBLT L,XY					Pixel Block Transfer, linear to XY													0000 1111 0010 0000
# -------------------------------------------------------------------------------------------------------------------------------------#
:PIXBLT_L_XY is bits_0_15=0xf20
{
	#
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# PIXBLT XY,L					Pixel Block Transfer, XY to linear													0000 1111 0100 0000
# -------------------------------------------------------------------------------------------------------------------------------------#
:PIXBLT_XY_L is bits_0_15=0xf40
{
	#
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# PIXBLT XY,XY					Pixel Block Transfer, XY to XY														0000 1111 0110 0000
# -------------------------------------------------------------------------------------------------------------------------------------#
:PIXBLT_XY_XY is bits_0_15=0xf60
{
	#
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# PIXT Rs,*Rd					Pixel Transfer - Register to Indirect												1111 100S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:PIXT Rs,*Rd is bits_9_15=0b1111100 & Rs & Rd
{
	#
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# PIXT Rs,*Rd.XY				Pixel Transfer - Register to Indirect.XY											1111 000S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:PIXT Rs,*Rd XY is bits_9_15=0b1111000 & Rs & Rd [XY = epsilon;]
{
	#
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# PIXT *Rs,Rd					Pixel Transfer - Indirect to Register												1111 101S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:PIXT *Rs,Rd is bits_9_15=0b1111101 & Rs & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# PIXT *Rs,*Rd					Pixel Transfer - Indirect to Indirect												1111 110S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:PIXT *Rs,*Rd is bits_9_15=0b1111110 & Rs & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# PIXT *Rs XY,Rd				Pixel Transfer - Indirect XY to Register											1111 001S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:PIXT *Rs XY,Rd is bits_9_15=0b1111001 & Rs & Rd [XY = epsilon;]
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# PIXT *Rs XY,*Rd XY			Pixel Transfer - Indirect XY to Indirect XY											1111 010S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:PIXT *Rs XY,*Rd xy is bits_9_15=0b1111010 & Rs & Rd [XY = epsilon; xy = epsilon;]
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# POPST							Pop Register Status on Stack														0000 0001 1100 0000
# -------------------------------------------------------------------------------------------------------------------------------------#
:POPST is word=0x01c0
{
	#done
	ST = *SP;
	SP = SP + 0x20;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# PUSHST						Push Register Status on Stack														0000 0001 1110 0000
# -------------------------------------------------------------------------------------------------------------------------------------#
:PUSHST is word=0x01e0
{
	#done
	SP = SP - 0x20;
	*SP = ST;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# PUTST Rs						Copy Register into Status															0000 0001 101R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:PUTST Rd is bits_5_15=0b00000001101 & Rd
{
	#done
	ST = Rd;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# RL K,Rd						Rotate Left - Constant																0011 00KK KKKR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:RL Constant,Rd is bits_10_15=0b001100 & Constant & Rd
{
	Rd = (Rd << Constant)|(Rd >> (32 - Constant));
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# RL Rs,Rd						Rotate Left - Register																0110 10SS SSSR DDDD*
# -------------------------------------------------------------------------------------------------------------------------------------#
:RL Rs,Rd is bits_9_15=0b0110100 & Rs & Rd
{
	Rd = (Rd << Rs)|(Rd >> (32 - Rs));
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# RETS							Return From Subroutine
# -------------------------------------------------------------------------------------------------------------------------------------#
:RETS is word = 0x0960
{ 
 	return [SP];
 	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# RETI							Return from Interrupt
# -------------------------------------------------------------------------------------------------------------------------------------#
:RETI is word = 0x0940
{ 
	return [SP];
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# SETC							Set Carry																			0000 1101 1110 0000
# -------------------------------------------------------------------------------------------------------------------------------------#
:SETC is word = 0xde0 [ C=1; globalset(inst_next,C); ]
{
	goto inst_next;
}

# -------------------------------------------------------------------------------------------------------------------------------------#
# SETF FS,FE,F					Set Field																			0000 01F1 01FS SSSS
# -------------------------------------------------------------------------------------------------------------------------------------#
:SETF bits_0_4,bits_5,bits_9 is bits_10_15=0b000001 &
	bits_9 & bits_6_8=0b101 & bits_5 &
	bits_0_4
{
	#todo: if fieldsize = 0, then make it 32 / 20h
	#:SETF" 10,1,0" is word = 0x0570 {}
	#:SETF" 20,1,1" is word = 0x0760 {}
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# SEXT Rd,F						Sign Extend to Long																	0000 01F1 01FS SSSS*
# -------------------------------------------------------------------------------------------------------------------------------------#
:SEXT Rd,bits_9 is bits_10_15=0b000001 & bits_9 & bits_5_8 & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# SLA K,Rd						Shift Left Arithmetic, Constant														0010 00KK KKKR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:SLA Constant,Rd is bits_10_15=0b001000 & Constant & Rd
{
	
	local msb_old:1 = (*Rd >> 31) & 1;					# Get MSB Bit for overflow flag
	Rd = Rd << Constant;
	local msb_new:1 = (*Rd >> 31) & 1;					# Get MSB Bit for overflow flag
	
	#update flags
	Update_N_Flag(Rd);
	$(C_Flag) = ((32 - Constant) >> Rd) &  1;		# Set to the value of last bit shifted out, 0 for shift count of 0
	Update_Z_Flag(Rd);
	$(V_Flag) = msb_old != msb_new;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# SLA Rs,Rd						Shift Left Arithmetic, Register														0110 000S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:SLA Rs,Rd is bits_9_15=0b0110000 & Rs & Rd
{
	local Rsv:1 = Rs:1 & 31;								# Only 5 LSB are taken
	local msb_old:1 = (*Rd >> 31) & 1;					# Get MSB Bit for overflow flag
	Rd = Rd << Rsv;
	local msb_new:1 = (*Rd >> 31) & 1;					# Get MSB Bit for overflow flag
	
	#update flags
	Update_N_Flag(Rd);
	$(C_Flag) = ((32 - Rsv) >> Rd) &  1;		# Set to the value of last bit shifted out, 0 for shift count of 0
	Update_Z_Flag(Rd);
	$(V_Flag) = msb_old != msb_new;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# SLL K,Rd						Shift Left Logical, Constant														0010 01KK KKKR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:SLL Constant,Rd is bits_10_15=0b001001 & Constant & Rd
{
	Rd = Rd << Constant;
	
	#update flags
	# N = Unaffected
	# $(C_Flag) = NEEDS DONE
	Update_Z_Flag(Rd);
	# V = Unaffected
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# SLL Rs,Rd						Shift Left Logical, Register														0110 001S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:SLL Rs,Rd is bits_9_15=0b0110001 & Rs & Rd
{
	local K = Rs & 31;
	Rd = Rd << K;
	
	#update flags
	# N = Unaffected
	# C = NEEDS DONE
	Update_Z_Flag(Rd);
	# V = Unaffected 
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# SRA K,Rd						Shift Right Arithmetic, Constant													0010 10KK KKKR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:SRA Constant,Rd is bits_10_15=0b001010 & Constant & Rd
{
	Rd = Rd >> Constant;
	
	#update flags
	Update_N_Flag(Rd);
	$(C_Flag) = ((32 - Constant) >> Rd) &  1;		# Set to the value of last bit shifted out, 0 for shift count of 0
	Update_Z_Flag(Rd);
	# V = Unaffected
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# SRA Rs,Rd						Shift Right Arithmetic, Register													0110 010S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:SRA Rs,Rd is bits_9_15=0b0110010 & Rs & Rd
{
	local Rsv:1 = Rs:1 & 31;
	Rd = Rd >> Rsv;
	
	#update flags
	Update_N_Flag(Rd);
	$(C_Flag) = ((Rsv - 1) >> Rd) &  1;		# Set to the value of last bit shifted out, 0 for shift count of 0
	Update_Z_Flag(Rd);
	# V = Unaffected
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# SRL K,Rd						Shift Right Logical, Constant														0010 11KK KKKR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:SRL Constant,Rd is bits_10_15=0b001011 & Constant & Rd
{
	Rd = Rd >> Constant;
	
	#update flags
	Update_N_Flag(Rd);
	$(C_Flag) = ((Constant - 1) >> Rd) &  1;		# Set to the value of last bit shifted out, 0 for shift count of 0
	Update_Z_Flag(Rd);
	# V = Unaffected
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# SRL Rd,Rs						Shift Right Logical, Register														0110 011S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:SRL Rd,Rs is bits_9_15=0b0110011 & Rs & Rd
{
	Rd = Rd >> Rs;
	
	#update flags
	# N = Unaffected
	# C = Set to the value of last bit shifted out, 0 for shift count of 0.
	Update_Z_Flag(Rd);
	# V Unaffected
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# SUB Rs,Rd						Subtract Registers																	0100 010S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:SUB Rs,Rd is bits_9_15=0b0100010 & Rs & Rd
{
	Rd = Rd - Rs;
	
	#update flags
	Update_N_Flag(Rd);
	# C = 1 if there is a borrow, 0 otherwise.
	Update_Z_Flag(Rd);
	# = 1 if there is an overflow, 0 otherwise
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# SUBB Rs,Rd					Subtract Registers with Borrow														0100 011S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:SUBB Rs,Rd is bits_9_15=0b0100011 & Rs & Rd
{
	Rd = Rd - Rs - (zext($(C_Flag)));
	
	#update flags
	Update_N_Flag(Rd);
	Update_C_Flag(Rd);
	Update_Z_Flag(Rd);
	Update_V_Flag(Rd);
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# SUBI IW,Rd					Subtract Immediate (16-bits)														0000 1011 111R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:SUBI IW,Rd is bits_5_15=0b00001011111 & Rd;
word [IW = ~word;]
{
	Rd = Rd - IW;
	
	#update flags
	Update_N_Flag(Rd);
	Update_C_Flag(Rd);
	Update_Z_Flag(Rd);
	Update_V_Flag(Rd);
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# SUBI IL,Rd					Subtract Immediate (32-bits)														0000 1101 000R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:SUBI IL,Rd is bits_5_15=0b00001101000 & Rd; imm32 [IL=~imm32;]
{
	Rd = Rd - IL;
	
	#update flags
	Update_N_Flag(Rd);
	Update_C_Flag(Rd);
	Update_Z_Flag(Rd);
	Update_V_Flag(Rd);
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# SUBK K,Rd						Subtract Constant (5-bits)															0001 01KK KKKR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:SUBK Constant,Rd is bits_10_15=0b000101 & Constant & Rd
{
	Rd = Rd - Constant;
	
	#update flags
	Update_N_Flag(Rd);
	Update_C_Flag(Rd);
	Update_Z_Flag(Rd);
	Update_V_Flag(Rd);
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# SUBXY Rs,Rd					Subtract Registers in XY Mode														1110 001S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:SUBXY Rs,Rd is bits_9_15=0b1110001 & Rs & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# TRAP							Software Interrupt																	0000 1001 000N NNNN
#
#	TRAP executes a software interrupt. The return address (the address of
#	next instruction) and then the status register are pushed onto the stack.
#	The IE (interrupt enable) bit in ST is set to 0, disabling maskable interrupts,
#	and ST is set to >0000 0010. Finally, the trap vector is loaded into the PC.
#	The TMS34010 generates the trap vector addresses as shown below: 
#
# -------------------------------------------------------------------------------------------------------------------------------------#
:TRAP bits_0_4 is bits_5_15=0b00001001000 & bits_0_4
{
	$(Interrupt) = 0;
	ST = 0x00000010;
	# PC = vector. Needs done. 
	
	$(N_Flag) = 0;
	$(C_Flag) = 0;
	$(Z_Flag) = 0;
	$(V_Flag) = 0;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# XOR Rd,Rs						Exclusive OR Registers																0101 011S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
# NOT USED COMMONly, same pattern as CLR Code. Cannot use Both.
#:XOR Rs,Rd is bits_9_15=0b0101011 & Rs & Rd
#{
	
#}


# -------------------------------------------------------------------------------------------------------------------------------------#
# XORI IL,Rd					Exclusive OR Immediate Value (32-bits)												0000 1011 110D DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:XORI imm32,Rd is bits_5_15=0b00001011110 & Rd; imm32
{
	Rd = Rd ^ imm32;
	
	#update flags
	# N = Unaffected
	# C = Unaffected
	Update_Z_Flag(Rd);
	# Z = Unaffected
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# ZEXT Rd,F						Zero Extend to Long																	0000 01F1 001R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:ZEXT Rd,bits_9 is bits_10_15=0b000001 & bits_9 & bits_5_8=0b1001 & Rd
{
	Rd = zext(Rd);
	
	#update flags
	# N = Unaffected
	# C = Unaffected
	Update_Z_Flag(Rd);
	# Z = Unaffected
}


# * = User Manual Unclear on Instruction, more than 1 method was shown...