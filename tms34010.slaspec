define endian=little;
define alignment=2;

#@include "tms34010.sinc"
#@define BASE_ADDRESS "0xff800000"

define space register	type=register_space 	size=4;
define space ram		type=ram_space			size=4;
define space input		type=ram_space			size=4;
define space rom		type=ram_space 			size=4 default;

define register offset=0x00 size=4 [ A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14 ] ;
define register offset=0x40 size=4 [ B0 B1 B2 B3 B4 B5 B6 B7 B8 B9 B10 B11 B12 B13 B14 ] ;

define register offset=0x80 size=4 [ PC ];
define register offset=0x7C size=4 [ SP ];
define register offset=0x84 size=4 [ ST ];
define register offset=0x88 size=2 [ MMTM ];
define register offset=0x8A size=2 [ MMFM ];

define context ST
	N 			= (31,31)
	C 			= (30,30)
	Z 			= (29,29)
	V 			= (28,28)
	unused2		= (26,27)
	pbx 		= (25,25)
	unused1		= (22,24)
	ie 			= (21,21)
	reserved1	= (12,20)
	fs_1_ext 	= (11,11)
	fs_1_size	= (6,10)
	fs_0_ext 	= (5,5)
	fs_0_size	= (0,4)
	;

define token reglist (16)
  c00=(0,0)
  c11=(1,1)
  c22=(2,2)
  c33=(3,3)
  c44=(4,4)
  c55=(5,5)
  c66=(6,6)
  c77=(7,7)
  c88=(8,8)
  c99=(9,9)
  cAA=(10,10)
  cBB=(11,11)
  cCC=(12,12)
  cDD=(13,13)
  cEE=(14,14)
  cFF=(15,15)
;
	

@define N_Flag "ST[31,1]"
@define C_Flag "ST[30,1]"
@define Z_Flag "ST[29,1]"
@define V_Flag "ST[28,1]"
@define FS1_Ext  "ST[11,1]"
@define FS1_Size "ST[6,5]"
@define FS0_Ext  "ST[5,1]"
@define FS0_Size "ST[0,5]"

define token size_word(16)
	word 		= (0,15)
;

define token tok32(32)
	imm32 		= (0,31)
	imm32s 		= (0,31) signed
	addr2 		= (0,31)
;

define token tok16(16)
	bits_11_15	= (11,15)		#dsjs
	bits_10_15	= (10,15)
	bits_10		= (10,10)		#dsjs
	bits_12_15 	= (12,15)
	bits_9_15	= (9,15)
	bits_9		= (9,9) dec
	bits_8_15	= (8,15)		#line z
	bits_8_11 	= (8,11)
	bits_7		= (7,7)			#line z
	bits_6_8	= (6,8)			#setf
	bits_5_15	= (5, 15)
	bits_5_9	= (5,9)
	bits_5_8_A	= (5,8)
	bits_5_8_B	= (5,8)
	bits_5_8	= (5,8)
	bits_5		= (5,5) dec		#setf
	bits_4		= (4,4)
	bits_0_8	= (0,8)
	bits_0_7s	= (0,7) signed
	bits_0_6	= (0,6)			#line z
	bits_0_3_A	= (0,3)
	bits_0_3_B	= (0,3)
	bits_0_15	= (0,15)
	bits_0_15s	= (0,15) signed
	bits_0_4	= (0,4)			# setf

	bits_8_11_B = (8,11)
	
	#offsets
	offset1 = (0,15) signed
	offset2 = (0,15) signed
;



# =====================================================================================================================================#
#
# 								TABLES
#
# =====================================================================================================================================#
attach variables [ bits_0_3_A ] [ A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14 SP ];
attach variables [ bits_0_3_B ] [ B0 B1 B2 B3 B4 B5 B6 B7 B8 B9 B10 B11 B12 B13 B14 SP ];
attach variables [ bits_5_8_A ] [ A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14 SP ];
attach variables [ bits_5_8_B ] [ B0 B1 B2 B3 B4 B5 B6 B7 B8 B9 B10 B11 B12 B13 B14 SP ];

# Rs
Rd: bits_0_3_A is bits_4=0 & bits_0_3_A { export bits_0_3_A; }
Rd: bits_0_3_B is bits_4=1 & bits_0_3_B { export bits_0_3_B; }
#Rd
Rs: bits_5_8_A is bits_4=0 & bits_5_8_A { export bits_5_8_A; }
Rs: bits_5_8_B is bits_4=1 & bits_5_8_B { export bits_5_8_B; }

Constant: bits_5_9 is bits_5_9 { export bits_5_9; }

macro move_from(tmp0, tmp1) {
	tmp0[0, 16] = *[ram]:2 Rs;
	tmp1 = tmp1 + 0x10;
	
	tmp0[16,16] = *[ram]:2 Rs;
	tmp1 = tmp1 + 0x10;
}

mmtm_0:       ,r0  is  r0 & Rd ; c00=1
{
	move_to(r, Rd);
}

mmtm_0:            is       Rd ; c00=0
{
	
}

mmtm_1: mmtm_0,r1  is  r1 & Rd ; c11=1 { move_to(r1, Rd);  build mmtm_0; }
mmtm_1: mmtm_0     is       Rd ; c11=0 {                   build mmtm_0; }

mmtm_2: mmtm_1,r2  is  r2 & Rd ; c22=1 { move_to(r2, Rd);  build mmtm_1; }
mmtm_2: mmtm_1     is       Rd ; c22=0 {                   build mmtm_1; }

mmtm_3: mmtm_2,r3  is  r3 & Rd ; c33=1 { move_to(r3, Rd);  build mmtm_2; }
mmtm_3: mmtm_2     is       Rd ; c33=0 {                   build mmtm_2; }

mmtm_4: mmtm_3,r4  is  r4 & Rd ; c44=1 { move_to(r4, Rd);  build mmtm_3; }
mmtm_4: mmtm_3     is       Rd ; c44=0 {                   build mmtm_3; }

mmtm_5: mmtm_4,r5  is  r5 & Rd ; c55=1 { move_to(r5, Rd);  build mmtm_4; }
mmtm_5: mmtm_4     is       Rd ; c55=0 {                   build mmtm_4; }

mmtm_6: mmtm_5,r6  is  r6 & Rd ; c66=1 { move_to(r6, Rd);  build mmtm_5; }
mmtm_6: mmtm_5     is       Rd ; c66=0 {                   build mmtm_5; }

mmtm_7: mmtm_6,r7  is  r7 & Rd ; c77=1 { move_to(r7, Rd);  build mmtm_6; }
mmtm_7: mmtm_6     is       Rd ; c77=0 {                   build mmtm_6; }

mmtm_8: mmtm_7,r8  is  r8 & Rd ; c88=1 { move_to(r8, Rd);  build mmtm_7; }
mmtm_8: mmtm_7     is       Rd ; c88=0 {                   build mmtm_7; }

mmtm_9: mmtm_8,r9  is  r9 & Rd ; c99=1 { move_to(r9, Rd);  build mmtm_8; }
mmtm_9: mmtm_8     is       Rd ; c99=0 {                   build mmtm_8; }

mmtm_a: mmtm_9,r10 is r10 & Rd ; cAA=1 { move_to(r10, Rd); build mmtm_9; }
mmtm_a: mmtm_9     is       Rd ; cAA=0 {                   build mmtm_9; }

mmtm_b: mmtm_a,r11 is r11 & Rd ; cBB=1 { move_to(r11, Rd); build mmtm_a; }
mmtm_b: mmtm_a     is       Rd ; cBB=0 {                   build mmtm_a; }

mmtm_c: mmtm_b,r12 is r12 & Rd ; cCC=1 { move_to(r12, Rd); build mmtm_b; }
mmtm_c: mmtm_b     is       Rd ; cCC=0 {                   build mmtm_b; }

mmtm_d: mmtm_c,r13 is r13 & Rd ; cDD=1 { move_to(r13, Rd); build mmtm_c; }
mmtm_d: mmtm_c     is       Rd ; cDD=0 {                   build mmtm_c; }

mmtm_e: mmtm_d,r14 is r14 & Rd ; cEE=1 { move_to(r14, Rd); build mmtm_d; }
mmtm_e: mmtm_d     is       Rd ; cEE=0 {                   build mmtm_d; }

tmlist: mmtm_e,sp  is  sp & Rd ; cFF=1 { move_to(sp, Rd);  build mmtm_e; }
tmlist: mmtm_e     is       Rd ; cFF=0 {                   build mmtm_e; }



# DSJS
addr5: fwd is bits_5_9 & bits_10 = 0 [fwd = inst_next + (bits_5_9 << 1);] {export *:4 fwd;}
addr5: bwd is bits_5_9 & bits_10 = 1 [bwd = inst_next - (bits_5_9 << 1);] {export *:4 bwd;}
addr8: addy is bits_0_7s [addy = inst_next + (bits_0_7s << 1);] {export *:4 addy;} 
addr16: addy is bits_0_15s [addy = inst_next + (bits_0_15s << 1);] {export *:4 addy;}
addr32: addy is imm32 [addy = (imm32 / 8) & 0xfffff;] {export *:4 addy;}

cc: "" is bits_8_11=0  	{ local tmp:1 = 1; export tmp; }
cc: "P"  is bits_8_11=1  { local tmp:1 = (!$(N_Flag) & !$(Z_Flag)) != 0; export tmp; }
cc: "LS" is bits_8_11=2  { local tmp:1 = ($(C_Flag) | $(N_Flag)) != 0; export tmp; }
cc: "HI" is bits_8_11=3  { local tmp:1 = (!$(C_Flag) & !$(N_Flag)) != 0; export tmp; }
cc: "LT" is bits_8_11=4  { local tmp:1 = ($(N_Flag) & !$(V_Flag)) | (!$(N_Flag) & $(V_Flag)) != 0; export tmp; }
cc: "GE" is bits_8_11=5  { local tmp:1 = ($(N_Flag) & $(V_Flag)) | (!$(N_Flag) & !$(V_Flag)) != 0; export tmp; }
cc: "LE" is bits_8_11=6  { local tmp:1 = ($(N_Flag) & !$(V_Flag)) | (!$(N_Flag) & $(V_Flag)) | $(Z_Flag) != 0; export tmp; }
cc: "GT" is bits_8_11=7  { local tmp:1 = ($(N_Flag) & $(V_Flag) & !$(Z_Flag)) | (!$(N_Flag) & !$(V_Flag) & !$(Z_Flag)) != 0; export tmp; }
cc: "C"	 is bits_8_11=8  { local tmp:1 = $(C_Flag) != 0; export tmp; }
cc: "NC" is bits_8_11=9  { local tmp:1 = !$(C_Flag) != 0; export tmp; }
cc: "EQ" is bits_8_11=10 { local tmp:1 = $(Z_Flag) != 0; export tmp; }
cc: "NE" is bits_8_11=11 { local tmp:1 = !$(Z_Flag) != 0; export tmp; }
cc: "V"  is bits_8_11=12 { local tmp:1 = $(V_Flag) != 0; export tmp; }
cc: "NV" is bits_8_11=13 { local tmp:1 = !$(V_Flag) != 0; export tmp; }
cc: "N"  is bits_8_11=14 { local tmp:1 = $(N_Flag) != 0; export tmp; }
cc: "NN" is bits_8_11=15 { local tmp:1 = !$(N_Flag) != 0; export tmp; }


# =====================================================================================================================================#
#
# 								MACROS
#
# =====================================================================================================================================#
macro move_from(tmp0, tmp1) {
	tmp0[0, 16] = *[ram]:2 Rs; tmp1 = tmp1 + 0x10;
	tmp0[16,16] = *[ram]:2 Rs; tmp1 = tmp1 + 0x10;
}

macro move_to(tmp0, tmp1) {
	tmp1 = tmp1 - 0x10; *[ram]:2 Rs = tmp0[0, 16];
	tmp1 = tmp1 - 0x10; *[ram]:2 Rs = tmp0[16,16];
}


# =====================================================================================================================================#
#
# 								SUBTABLES
#
# =====================================================================================================================================#

# -------------------------------------------------------------------------------------------------------------------------------------#
# ABS Rd						Store Absolute Value																0000 0011 100R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:ABS Rd is bits_5_15=0b00000011100 & Rd
{
	if(Rd > 0x80000000) goto <OVERFLOW>; #
	if(Rd == 0) goto <ZERO>;
	if(Rd < 0) goto <MAKE_POS>;
	
	#<POS>
	$(N_Flag) = 1;
	$(Z_Flag) = 0;
	
	
	<ZERO>
	$(N_Flag) = 0;
	$(Z_Flag) = 1;
	
	
	<OVERFLOW>
	$(V_Flag) = 1;
	
	<MAKE_POS>
	Rd = 0 - Rd;
	
	$(N_Flag) = 0; # set flag since original value was neg
}

# -------------------------------------------------------------------------------------------------------------------------------------#
# ADD Rs,Rd						Add Registers																		0100 000S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:ADD Rs,Rd is bits_9_15=0b0100000 & Rs & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# ADD Rs,Rd						Add Registers with Carry															0100 001S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:ADDC Rs,Rd is bits_9_15=0b0100001 & Rs & Rd
{
	#local newval:4 = Rs + Rd + $(C_Flag);
	Rd = Rd + Rs + $(C_Flag);
	$(N_Flag) = Rd s< 0;
	$(C_Flag) = Rd == 0;
	$(Z_Flag) = scarry(Rs, Rd) | scarry(Rs + Rd, $(C_Flag));
	$(V_Flag) = carry(Rs, Rd) | carry(Rs + Rd, $(C_Flag));
	#Rd = newval;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# ADDI IW						Add Immediate (16-bytes)															0000 1011 000R DDDD					
# -------------------------------------------------------------------------------------------------------------------------------------#
:ADDI word,Rd is bits_5_15=0b00001011000 & Rd; word
{
	Rd = Rd + word;
	$(N_Flag) = Rd s< 0;
	$(C_Flag) = carry(word,Rd);
	$(Z_Flag) = Rd == 0;
	$(V_Flag) = scarry(word,Rd);
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# ADDI IL						Add Immediate (32-bytes)															0000 1011 001R DDDD					
# -------------------------------------------------------------------------------------------------------------------------------------#
:ADDI imm32,Rd is bits_5_15=0b00001011001 & Rd; imm32
{
	Rd = Rd + imm32;
	$(N_Flag) = Rd s< 0;
	$(C_Flag) = carry(imm32, Rd);
	$(Z_Flag) = Rd == 0;
	$(V_Flag) = scarry(imm32, Rd);
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# ADDK K,Rd						Add Constant (5-bits)																0001 00KK KKKR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:ADDK Constant,Rd is bits_10_15=0b000100 & Constant & Rd
{
	Rd = Rd + Constant;
	$(N_Flag) = Rd s< 0;
	$(C_Flag) = carry(Constant, Rd);
	$(Z_Flag) = Rd == 0;
	$(V_Flag) = scarry(Constant, Rd);
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# ADDXY Rs,Rd					Add Registers in XY Mode															1110 000S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:ADDXY Rs,Rd is bits_9_15=0b1110000 & Rs & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# AND Rs,Rd						AND Registers																		0101 000S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:AND Rs,Rd is bits_9_15=0b0101000 & Rs & Rd
{
	Rd = Rs & Rd;
	$(V_Flag) = Rd == 0;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# ANDN Rs,Rd					AND Registers with Compliment														0101 001S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:ANDN Rs,Rd is bits_9_15=0b0101001 & Rs & Rd
{
	Rd = ~Rs & Rd; 
	
	# set flags
	if(Rd==0) goto <SET_Z_FLAG>;
	
	$(Z_Flag) = 0;
	goto inst_next;
	
	<SET_Z_FLAG>
	$(Z_Flag) = 1;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# ANDI IL,Rd					AND Immediate (32-bits)																0000 1011 100R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:ANDI IL,Rd is bits_5_15=0b00001011100 & Rd;
imm32 [IL=~imm32;]
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# ANDNI IL,Rd					AND NOT Immediate (32-bits)															0000 1011 101R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
# pattern might be wrong as ANDNI is the same as ANDI, error in manual?
#:ANDNI imm32,Rd is bits_5_15=0b00001011101 & Rd; imm32
#{
	
#}


# -------------------------------------------------------------------------------------------------------------------------------------#
#BTST 4h,a0						Test Register Bit, Constant															0001 11KK KKKR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:BTST K,Rd is bits_10_15=0b000111 & bits_5_9 & Rd [ K=~bits_5_9 & 0x1f; ]
 {
 	goto inst_next;
 }
	 
	 
# -------------------------------------------------------------------------------------------------------------------------------------#
#BTST Rs,Rd						Test Register Bit, Register															0100 101S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:BTST Rs,Rd is bits_9_15=0b0100101 & Rs & Rd
 {
 	goto inst_next;
 }


# -------------------------------------------------------------------------------------------------------------------------------------#
# CALL Rd						Call Register																		0000 1001 001R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:CALL Rd is bits_5_15=0b00001001001 & Rd
{
	*:4 SP = inst_next;
	SP=SP-4;
	call [Rd];
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# CALLA	FF805000				Call Absolute Address																0000 1101 0101 1111
# -------------------------------------------------------------------------------------------------------------------------------------#
:CALLA addr32 is word=0x0D5F; addr32
{
	*:4 SP = inst_next;
	SP=SP-4;
	call [addr32];
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# CALLR FF805000	Call Relative Address									0000  1101 0011 1111
# -------------------------------------------------------------------------------------------------------------------------------------#
:CALLR addr16 is bits_0_15=0x0D3F; addr16
{ 
	*:4 SP = inst_next;
	SP=SP-4;
	call addr16;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# CLR Rd					Clear Register									0101 011D DDDR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:CLR Rd is bits_9_15=0b0101011 & bits_5_8_A & Rd
{
	#XOR itself to clear+
	# Rd = Rd ^ Rd;
	Rd = 0;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# CLRC							Clear Carry																			0000 0011 0010 0000
# -------------------------------------------------------------------------------------------------------------------------------------#
:CLRC is word=0x320 [ C=1; globalset(inst_next,C); ]
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# CMP Rs,Rd						Compare Registers																	0100 100S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:CMP Rs, Rd is bits_9_15=0b0100100 & Rs & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# CMPI							Compare Immediate (16-bits)															0000 1011 010R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:CMPI IW,Rd is bits_5_15=0b00001011010 & Rd; bits_0_15s
[IW = ~bits_0_15s;]
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# CMPI							Compare Immediate (32-bits)															0000 1011 011R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:CMPI IL,Rd is bits_5_15=0b00001011011 & Rd; imm32s
[IL = ~imm32s;]
{

	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# CMPXY Rs,Rd					Compare X and Y halves of Registers													1110 010S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:CMPXY Rs,Rd is bits_9_15=0b1110010 & Rs & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# CPW Rs,Rd						Compare Point to Window																1110 011S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:CMPW Rs,Rd is bits_9_15=0b1110011 & Rs & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# CVXYL Rd,Rs					Convert XY Address to Linear Address												1110 100S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:CVXYL Rd,Rs is bits_9_15=0b1110100 & Rs & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# DEC Rd						Decrement Register																	0001 0100 001R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:DEC Rd is bits_5_15=0b00010100001 & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# Disable Interrupts
# -------------------------------------------------------------------------------------------------------------------------------------#
:DINT is word = 0x0360
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# DIVS Rs,Rd					Divide Registers Signed																0101 100S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:DIVS Rs,Rd is bits_9_15=0b0101100 & Rs & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# DIVU Rs,Rd					Divide Registers Unsigned															0101 101S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:DIVU Rs,Rd is bits_9_15=0b0101101 & Rs & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# DRAV Rs,Rd					Draw and Advance																	1111 011S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:DRAV Rs,Rd is bits_9_15=0b1111011 & Rs & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# DSJ Rd,Address				Decrement Register and skip															0000 1101 100R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:DSJ Rd,addr16 is bits_5_15=0b00001101100 & Rd; addr16
{
		Rd = Rd -1;
		if ( Rd != 0) goto addr16;		
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# DSJEQ Rd,Address				Conditionally Decrement Register and skip											0000 1101 101R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:DSJEQ Rd,addr16 is bits_5_15=0b00001101101 & Rd; addr16
{
		if($(Z_Flag)==0) goto inst_next;
		Rd = Rd -1;
		if ( Rd != 0) goto addr16;		
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# DSJEQ Rd,Address				Conditionally Decrement Register and skip											0000 1101 110R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:DSJNE Rd,addr16 is bits_5_15=0b00001101110 & Rd; addr16
{
		if($(Z_Flag)==1) goto inst_next;
		Rd = Rd -1;
		if ( Rd != 0) goto addr16;		
}

# -------------------------------------------------------------------------------------------------------------------------------------#
# DSJS Rd,Address				Decrement Register and skip jump short.												0011 1DKK KKKR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:DSJS Rd,addr5 is bits_11_15=0b00111 & addr5 & Rd
{
		Rd = Rd -1;
		if ( Rd != 0) goto addr5;		
}

# -------------------------------------------------------------------------------------------------------------------------------------#
# Enable Interrupts
# -------------------------------------------------------------------------------------------------------------------------------------#
:EINT is word = 0x0D60
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# EMU							Initiate Emulation																	0000 0001 0000 0000
# -------------------------------------------------------------------------------------------------------------------------------------#
:EMU is bits_0_15=0x100
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# EXGF Rd,F						Exchange Field Size																	1101 01F1 000R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:EXGF Rd,bits_9 is bits_10_15=0b110101 & bits_9 & bits_5_8=0b1000 & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# EXGPC Rd						Exchange Program Counter with Register												0000 0001 001R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:EXGPC Rd is bits_5_15=0b00000001001 & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# FILL L						Fill Array with processed pixels, Linear											0000 1111 1100 0000
# -------------------------------------------------------------------------------------------------------------------------------------#
:FILL_L is bits_0_15=0xfc0
{
	#
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# FILL XY						Fill Array with processed pixels, XY												0000 1111 1110 0000
# -------------------------------------------------------------------------------------------------------------------------------------#
:FILL_XY is bits_0_15=0xfe0
{
	#
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# GETPC	Rd						Get Program Counter into Register													0000 0001 010R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:GETPC Rd is bits_5_15=0b00000001010 & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# GETST Rd						Get Status Register into Register													0000 0001 100R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:GETST Rd is bits_5_15=0b00000001100 & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# INC Rd						Increment Register																	0001 0000 001R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:INC Rd is bits_5_15=0b00010000001 & Rd
{
	goto inst_next;
}

# -------------------------------------------------------------------------------------------------------------------------------------#
# JAcc Address					Absolute Address Conditional														1100 cond 1000 0000
# -------------------------------------------------------------------------------------------------------------------------------------#
:JA^cc addr32 is cc & bits_12_15=0b1100 &  bits_0_7s=0b10000000; addr32
{
	if (cc) goto addr32;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
#JRcc Address					Jump Relative Conditonal Long														1100 cond 0000 0000
# -------------------------------------------------------------------------------------------------------------------------------------#
:JR^cc addr16 is cc & bits_12_15=0b1100 & bits_0_7s=0; addr16
{
	if(cc) goto addr16;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
#JRcc Address					Jump Relative Conditional Short														1100 cond xxxx xxxx
# -------------------------------------------------------------------------------------------------------------------------------------#
#attach names [ bits_8_11_B ] [ UC P LS HI LT GE LE GT C NC EQ NE V NV N NN ];
:JR^cc addr8 is cc & bits_12_15=0b1100 & addr8
{
	if(cc) goto addr8;
}



# -------------------------------------------------------------------------------------------------------------------------------------#
# JUMP Rd						Jump Indirect																		0000 0001 011R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
# Will throw errors since register won't natively have a valid address.
:JUMP Rd is bits_5_15=0b00000001011 & Rd
{
	goto Rd;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# LINE Z						Line Draw																			1101 1111 Z001 1010
# -------------------------------------------------------------------------------------------------------------------------------------#
:LINE bits_7 is bits_8_15=0b11011111 & bits_7 & bits_0_6=0b0011010
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# LMO Rs,Rd						Leftmost One																		0110 101S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:LMO Rs,Rd is bits_9_15=0b0110101 & Rs & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MMTM Rd,List					Move Multiple Registers To Memory													0000 1001 100R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
#SP A14 A13 A12 A11 A10 A9 A8 A7 A6 A5 A4 A3 A2 A1 AO
:MMTM Rd^tmlist is bits_5_15=0b00001001100 & Rd & tmlist
{
	build tmlist;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MMFM Rs,List					Move Multiple Registers From Memory													0000 1001 101R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MMFM Rd^fmlist is bits_5_15=0b00001001101 & Rd & fmlist
{
	build fmlist;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MODS Rs,Rd					Modulus Signed																		0110 110S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MODS Rs,Rd is bits_9_15=0b0110110 & Rs & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MODU Rs,Rd					Modulus Unsigned																	0110 111S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MODU Rs,Rd is bits_9_15=0b0110111 & Rs & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MPYS Rs,Rd					Multiply Registers (Signed)															0101 110S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MPYS Rs,Rd is bits_9_15=0b0101110 & Rs & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MPYU Rs,Rd					Multiply Registers (Unsigned)														0101 111S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MPYU Rs,Rd is bits_9_15=0b0101111 & Rs & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVB Rs,*Rd					Move Byte - Register to Indirect													1000 110S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVB Rs,*Rd is bits_9_15=0b1000110 & Rs & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVB *Rs,Rd					Move Byte - Indirect to Register													1000 111S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVB *Rs,Rd is bits_9_15=0b1000111 & Rs & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVB *Rs,*Rd					Move Byte - Indirect to Indirect													1001 110S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVB *Rs,*Rd is bits_9_15=0b1001110 & Rs & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVB *Rs,*Rd(Disp)			Move Byte - Indirect to Indirect with Displacement									1010 110S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVB *Rs,*Rd(offset2) is bits_9_15=0b1010110 & Rs & Rd; offset2
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVB *Rs(Disp,*Rd			Move Byte - Indirect with Displacement to Indirect										1010 111S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVB *Rs(offset1),*Rd is bits_9_15=0b1010111 & Rs & Rd; offset1
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVB *Rs(Disp),*Rd(Disp)			Move Byte - Indirect with Displacement to Indirect with Displacement			1011 110S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVB *Rs(offset1),*Rd(offset2) is bits_9_15=0b1011110 & Rs & Rd; offset1; offset2
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVB Rs,@DAddress					Move Byte - Register to Absolute												0000 0101 111R SSSS
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVB Rd,imm32 is bits_5_15=0b00000101111 & Rd; imm32
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVB @SAddress,Rd					Move Byte - Absolute to Register												0000 0111 111R SSSS
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVB imm32,Rd is bits_5_15=0b00000111111 & Rd; imm32
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVB @SAddress,@DAddress			Move Byte - Absolute to Absolute												0000 0011 0100 0000
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVB imm32,@addr2 is word=0x340; imm32;addr2
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE Rs,Rd					Move Register to Register															0100 11MS SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVE Rs,Rd is bits_10_15=0b010011 & bits_9 & Rd & bits_4 & Rs
{
	Rs = Rd;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE Rs,*Rd,F					Move Field - Register to Indirect													1000 00FS SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVE Rs, *Rd, bits_9 is bits_10_15=0b100000 & bits_9 & Rd & bits_4 & Rs
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE Rs,-*Rd,F				Move Field - Register to Indirect(Predecrement)										1010 00FS SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVE Rs, -*Rd, bits_9 is bits_10_15=0b101000 & bits_9 & Rd & bits_4 & Rs
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE Rs,*Rd+,F				Move Field - Register to Indirect(Post Inc)											1001 00FS SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVE Rs, *Rd+, bits_9 is bits_10_15=0b100100 & bits_9 & Rd & bits_4 & Rs
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE *Rs,Rd,F					Move Field - Indirect to Register													1000 01FS SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVE *Rs, Rd, bits_9 is bits_10_15=0b100001 & bits_9 & Rd & bits_4 & Rs
{
	Rs = *[register]Rd;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE -*Rs,Rd,F				Move Field - Indirect (Pre Inc) to Register											1010 01FS SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVE -*Rs, Rd, bits_9 is bits_10_15=0b101001 & bits_9 & Rd & bits_4 & Rs
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE *Rs+,Rd,F				Move Field - Indirect (Post Inc) to Register										1001 01FS SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVE *Rs+, Rd, bits_9 is bits_10_15=0b100101 & bits_9 & Rd & bits_4 & Rs
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE *Rs,*Rd,F				Move Field - Indirect to Indirect													1000 10FS SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVE *Rs, *Rd, bits_9 is bits_10_15=0b100010 & bits_9 & Rd & bits_4 & Rs
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE -*Rs,-*Rd,F				Move Field - Indirect(Predecrement) to Indirect(Predecrement)						1010 10FS SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVE -*Rs, -*Rd, bits_9 is bits_10_15=0b101010 & bits_9 & Rd & bits_4 & Rs
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE *Rs+,*Rd+,F				Move Field - Indirect(Postincrement) to Indirect(Postincrement)						1010 10FS SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVE *Rs+, *Rd+, bits_9 is bits_10_15=0b100110 & bits_9 & Rd & bits_4 & Rs
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE Rs,*Rd(Disp),F			Move Field - Register to Indirect(Displacement)										1011 00FS SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVE Rs, *Rd(offset2), bits_9 is bits_10_15=0b101100 & bits_9 & Rd & bits_4 & Rs;
offset2
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE *Rs(Disp),Rd,F			Move Field - Indirect(Displacement) to Register										1011 01FS SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVE *Rs(offset1), Rd, bits_9 is bits_10_15=0b101101 & bits_9 & Rd & bits_4 & Rs;
offset1
{
	
	#N 1 if the field-extended data moved to register is negative, 0 otherwise.
	#C Unaffected
	#Z 1 if the field-extended data moved to register is 0, 0 otherwise.
	#V 0
	
	Rd = *Rs + offset1; 
	#local s16 = *Rs;

}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE *Rs(Disp),*Rd+,F			Move Field - Indirect(Displacement) to Indirect (Post Increment)					1101 00FS SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVE *Rs(offset1), *Rd+, bits_9 is bits_10_15=0b110100 & bits_9 & Rs & Rd;
offset1
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE *Rs(Disp),*Rd(Disp),F	Move Field - Indirect(Displacement) to Indirect (Displacement)						1011 10FS SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVE *Rs(offset1), *Rd(offset2), bits_9 is bits_10_15=0b101110 & bits_9 & Rs & Rd;
offset1; offset2
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE Rs,@DAddress,F			Move Field - Register to Absolute													0000 01F1 100R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVE Rd,imm32,bits_9 is bits_10_15=0b000001 & bits_9 & bits_5_8=0b1100 & Rd;
imm32
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE @SAddress,Rd,F			Move Field - Absolute to Register													0000 01F1 101R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVE imm32,Rd,bits_9 is bits_10_15=0b000001 & bits_9 & bits_5_8=0b1101 & Rd;
imm32
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE @SAddress,*Rd+,F			Move Field - Absolute to Indirect (Postincrement)									1101 01F0 000R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVE imm32,*Rd+,bits_9 is bits_10_15=0b110101 & bits_9 & bits_5_8=0b0000 & Rd;
imm32
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVE @SAddress,@DAddress,F	Move Field - Absolute to Absolute													0000 01F1 1100 DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
# TODO: Error: Equal constraint is impossible to match: for table "instruction" constructor from tms34010.slaspec:881
:MOVE imm32,@addr2,bits_9 is bits_10_15=0b000001 & bits_9 & bits_0_8=0b111000000;
imm32; addr2
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVI IW,Rd					Move Immediate (16-bits)															0000 1001 110R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVI bits_0_15,Rd is bits_5_15=0b00001001110 & Rd; bits_0_15
{ 
	Rd = bits_0_15;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVI IL,Rd					Move Immediate (32-bits)															0000 1001 111R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVI imm32,Rd is bits_5_15=0b00001001111 & Rd; imm32
{
	Rd = imm32;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVK 1h,A1					Move Constant																		0001 10KK KKKR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVK Constant,Rd is bits_10_15=0b000110 & Constant & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVX Rs,Rd					Move X half of register																1110 110S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVX Rs,Rd is bits_9_15=0b1110110 & Rs & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# MOVY Rs,Rd					Move Y half of register																1110 111S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:MOVY Rs,Rd is bits_9_15=0b1110111 & Rs & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# NEG Rd						Negate Register																		0000 0011 101R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:NEG Rd is bits_5_15=0b00000011101 & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# NEG Rd						Negate Register	with Borrow															0000 0011 110R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:NEGB Rd is bits_5_15=0b00000011110 & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# No Operation
# -------------------------------------------------------------------------------------------------------------------------------------#
:NOP is word = 0x300
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# NOT Rd						Not Register																		0000 0011 111R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:NOT Rd is bits_5_15=0b00000011111 & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# OR Rs,Rd					OR Registers																		0101 010S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:OR Rs,Rd is bits_9_15=0b0101010 & Rs & Rd
{
	#
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# ORI L,Rd						OR Immediate (32-bits)																0000 1011 101R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:ORI imm32,Rd is bits_5_15=0b00001011101 & Rd; imm32
{
	#
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# PIXBLT B,L					Pixel Block transfer, binary to linear												0000 1111 1000 0000
# -------------------------------------------------------------------------------------------------------------------------------------#
:PIXBLT_B_L is bits_0_15=0xf80
{
	#
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# PIXBLT B,XY					Pixel Block transfer, and expand, binary to XY										0000 1111 1010 0000
# -------------------------------------------------------------------------------------------------------------------------------------#
:PIXBLT_B_XY is bits_0_15=0xfa0
{
	#
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# PIXBLT L,L					Pixel Block transfer, linear to linear												0000 1111 0000 0000
# -------------------------------------------------------------------------------------------------------------------------------------#
:PIXBLT_L_L is bits_0_15=0xf00
{
	#
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# PIXBLT L,XY					Pixel Block Transfer, linear to XY													0000 1111 0010 0000
# -------------------------------------------------------------------------------------------------------------------------------------#
:PIXBLT_L_XY is bits_0_15=0xf20
{
	#
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# PIXBLT XY,L					Pixel Block Transfer, XY to linear													0000 1111 0100 0000
# -------------------------------------------------------------------------------------------------------------------------------------#
:PIXBLT_XY_L is bits_0_15=0xf40
{
	#
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# PIXBLT XY,XY					Pixel Block Transfer, XY to XY														0000 1111 0110 0000
# -------------------------------------------------------------------------------------------------------------------------------------#
:PIXBLT_XY_XY is bits_0_15=0xf60
{
	#
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# PIXT Rs,*Rd					Pixel Transfer - Register to Indirect												1111 100S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:PIXT Rs,*Rd is bits_9_15=0b1111100 & Rs & Rd
{
	#
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# PIXT Rs,*Rd.XY				Pixel Transfer - Register to Indirect.XY											1111 000S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:PIXT Rs,*Rd XY is bits_9_15=0b1111000 & Rs & Rd [XY = epsilon;]
{
	#
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# PIXT *Rs,Rd					Pixel Transfer - Indirect to Register												1111 101S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:PIXT *Rs,Rd is bits_9_15=0b1111101 & Rs & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# PIXT *Rs,*Rd					Pixel Transfer - Indirect to Indirect												1111 110S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:PIXT *Rs,*Rd is bits_9_15=0b1111110 & Rs & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# PIXT *Rs XY,Rd				Pixel Transfer - Indirect XY to Register											1111 001S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:PIXT *Rs XY,Rd is bits_9_15=0b1111001 & Rs & Rd [XY = epsilon;]
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# PIXT *Rs XY,*Rd XY			Pixel Transfer - Indirect XY to Indirect XY											1111 010S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:PIXT *Rs XY,*Rd xy is bits_9_15=0b1111010 & Rs & Rd [XY = epsilon; xy = epsilon;]
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# POPST							Pop Register Status on Stack														0000 0001 1100 0000
# -------------------------------------------------------------------------------------------------------------------------------------#
:POPST is word=0x01c0
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# PUSHST						Push Register Status on Stack														0000 0001 1110 0000
# -------------------------------------------------------------------------------------------------------------------------------------#
:PUSHST is word=0x01e0
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# PUTST Rs						Copy Register into Status															0000 0001 101R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:PUTST Rd is bits_5_15=0b00000001101 & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# RL K,Rd						Rotate Left - Constant																0011 00KK KKKR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:RL Constant,Rd is bits_10_15=0b001100 & Constant & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# RL Rs,Rd						Rotate Left - Register																0110 10SS SSSR DDDD*
# -------------------------------------------------------------------------------------------------------------------------------------#
:RL Rs,Rd is bits_9_15=0b0110100 & Rs & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# RETS							Return From Subroutine																0000 1001 0110 0000
# -------------------------------------------------------------------------------------------------------------------------------------#
:RETS is bits_5_15=0b00001001011 & bits_0_4=0
{ 
 	#local ea:4 = *[ram]:4 SP;
    #SP = SP + 0x20;
    #return [ea];
 	return [SP];
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# RETS N						Return From Subroutine w/ Increment													0000 1001 011N NNNN
# -------------------------------------------------------------------------------------------------------------------------------------#
:RETS bits_0_4 is bits_5_15=0b00001001011 & bits_0_4
{ 
    local ea:4 = *[ram]:4 SP;
    SP = SP + 0x20 + (bits_0_4 << 4);
    return [ea];
 	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# RETI							Return from Interrupt																0000 1001 0100 0000
# -------------------------------------------------------------------------------------------------------------------------------------#
:RETI is word = 0x0940
{ 
   
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# SETC							Set Carry																			0000 1101 1110 0000
# -------------------------------------------------------------------------------------------------------------------------------------#
:SETC is word = 0xde0 [ C=1; globalset(inst_next,C); ]
{
	goto inst_next;
}

# -------------------------------------------------------------------------------------------------------------------------------------#
# SETF FS,FE,F					Set Field																			0000 01F1 01FS SSSS
# -------------------------------------------------------------------------------------------------------------------------------------#
:SETF bits_0_4,bits_5,bits_9 is bits_10_15=0b000001 &
	bits_9 & bits_6_8=0b101 & bits_5 &
	bits_0_4
{
	#todo: if fieldsize = 0, then make it 32 / 20h
	#:SETF" 10,1,0" is word = 0x0570 {}
	#:SETF" 20,1,1" is word = 0x0760 {}
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# SEXT Rd,F						Sign Extend to Long																	0000 01F1 01FS SSSS*
# -------------------------------------------------------------------------------------------------------------------------------------#
:SEXT Rd,bits_9 is bits_10_15=0b000001 & bits_9 & bits_5_8 & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# SLA K,Rd						Shift Left Arithmetic, Constant														0010 00KK KKKR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:SLA Constant,Rd is bits_10_15=0b001000 & Constant & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# SLA Rs,Rd						Shift Left Arithmetic, Register														0110 000S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:SLA Rs,Rd is bits_9_15=0b0110000 & Rs & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# SLL K,Rd						Shift Left Logical, Constant														0010 01KK KKKR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:SLL Constant,Rd is bits_10_15=0b001001 & Constant & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# SLL Rs,Rd						Shift Left Logical, Register														0110 001S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:SLL Rs,Rd is bits_9_15=0b0110001 & Rs & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# SRA K,Rd						Shift Right Arithmetic, Constant													0010 10KK KKKR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:SRA Constant,Rd is bits_10_15=0b001010 & Constant & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# SRA Rs,Rd						Shift Right Arithmetic, Register													0110 010S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:SRA Rs,Rd is bits_9_15=0b0110010 & Rs & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# SRL K,Rd						Shift Right Logical, Constant														0010 11KK KKKR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:SRL Constant,Rd is bits_10_15=0b001011 & Constant & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# SRL Rd,Rs						Shift Right Logical, Register														0110 011S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:SRL Rd,Rs is bits_9_15=0b0110011 & Rs & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# SUB Rs,Rd						Subtract Registers																	0100 010S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:SUB Rs,Rd is bits_9_15=0b0100010 & Rs & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# SUBB Rs,Rd					Subtract Registers with Borrow														0100 011S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:SUBB Rs,Rd is bits_9_15=0b0100011 & Rs & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# SUBI IW,Rd					Subtract Immediate (16-bits)														0000 1011 111R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:SUBI IW,Rd is bits_5_15=0b00001011111 & Rd;
word [IW = ~word;]
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# SUBI IL,Rd					Subtract Immediate (32-bits)														0000 1101 000R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:SUBI IL,Rd is bits_5_15=0b00001101000 & Rd; imm32 [IL=~imm32;]
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# SUBK K,Rd						Subtract Constant (5-bits)															0001 01KK KKKR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:SUBK Constant,Rd is bits_10_15=0b000101 & Constant & Rd
{
	goto inst_next;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# SUBXY Rs,Rd					Subtract Registers in XY Mode														1110 001S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:SUBXY Rs,Rd is bits_9_15=0b1110001 & Rs & Rd
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# TRAP							Software Interrupt																	0000 1001 000N NNNN
# -------------------------------------------------------------------------------------------------------------------------------------#
:TRAP bits_0_4 is bits_5_15=0b00001001000 & bits_0_4
{
	$(N_Flag) = 0;
	$(C_Flag) = 0;
	$(Z_Flag) = 0;
	$(V_Flag) = 0;
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# XOR Rd,Rs						Exclusive OR Registers																0101 011S SSSR DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
# NOT USED COMMONly, same pattern as CLR Code. Cannot use Both.
#:XOR Rs,Rd is bits_9_15=0b0101011 & Rs & Rd
#{
	
#}


# -------------------------------------------------------------------------------------------------------------------------------------#
# XORI IL,Rd					Exclusive OR Immediate Value (32-bits)												0000 1011 110D DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:XORI imm32,Rd is bits_5_15=0b00001011110 & Rd; imm32
{
	
}


# -------------------------------------------------------------------------------------------------------------------------------------#
# ZEXT Rd,F						Zero Extend to Long																	0000 01F1 001R DDDD
# -------------------------------------------------------------------------------------------------------------------------------------#
:ZEXT Rd,bits_9 is bits_10_15=0b000001 & bits_9 & bits_5_8=0b1001 & Rd
{
	
}


# * = User Manual Unclear on Instruction, more than 1 method was shown...